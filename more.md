遇到了CORS跨域资源共享问题 在处理下载请求的时候 前端向静态资源服务器发出请求 发生跨域资源问题 
跨域资源共享问题概括为:在A服务器的前端访问B服务器的资源 B服务器是否允许问题
解决方案:
在nginx配置文件加上
add_header 'Access-Control-Allow-Origin' '*';
add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS';

该项目分为几个模块
第一是用户的注册和登录
用户注册时先简单校验账号密码再通过rpc调用讲账号密码传递给独立的注册服务器 注册服务器负责讲加密后的密码和用户账号写入数据库
登录模块从数据库中取出对应的哈希密码 判断密码是否正确 若正确将密码加密生成token发送给客户端 客户端在localstorage里保存下来username和token从而保持登录状态
第二是文件上传模块
用户将个人的文件上传到服务器 服务器将文件信息保存到数据库 并使用阿里云OSS备份文件
第三是文件下载模块
用户在客户端点击下载会将文件信息传递给nginx nginx传发给非静态资源服务器 该服务器生成对应文件的实际路径再返回到客户端 客户端重发实际路径 从nginx静态资源服务器获取文件

1 为什么选择 RabbitMQ？相比其他消息队列（如 Kafka、Redis Stream），它的优势是什么？
他有高可靠性、灵活的路由机制，以及对实时性业务的适配能力。在文件上传、异步任务处理等场景中，它能有效解耦系统组件，保证消息不丢失

2.Publisher 和 Consumer 的实现中，如何保证消息的可靠性？
发布者 Publisher Confirms + 持久化	确保消息到达 Broker
Broker 队列持久化 + 镜像队列	防止消息丢失和单点故障
消费者 手动 ACK + 死信队列 + 幂等性	确保消息正确处理且不重复消费
3.Consumer 的 doConsume 方法中，为什么设置了 3000ms 的超时时间
保障系统稳定性：防止资源耗尽和故障扩散。
提升吞吐量：通过及时释放资源，维持高并发处理能力。
4.你提到需要在 RabbitMQ 管理界面创建 Exchanges、Queues 和 Bindings，为什么不在代码中动态创建？
安全、一致、易维护、性能优化
5.RabbitMQ 的配置发生变化（如队列名或路由键变更），你的代码是否需要修改？如何提高配置的灵活性？
配置外部化	通用场景	快速变更，无需修改代码
6.如果文件较大（如 1GB 以上），用户下载时可能会中断，如何处理？
启用 HTTP Range 请求	支持断点续传，减少重复下载
